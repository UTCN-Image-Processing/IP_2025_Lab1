name: Build and Test

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    permissions:
      checks: write
      contents: read

    steps:
      # Step 1: Checkout Student Repository
      - name: Checkout Student Repo
        uses: actions/checkout@v3

      # Step 2: Checkout Private Tests Repository
      - name: Checkout Private Tests Repo
        uses: actions/checkout@v3
        with:
          repository: mbjurca/IP_2025_Lab1_tests
          token: ${{ secrets.TEST_REPO_TOKEN }}  # Ensure this secret is set in the private tests repo
          path: private_tests
          ref: main

      # Step 3: Copy Student Code into Private Tests
      - name: Copy Student Code into Private Tests
        run: |
          cp src/lab1.cpp private_tests/src/lab1.cpp
          cp src/lab1.h   private_tests/src/lab1.h

      # Step 4: Install Dependencies
      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y cmake g++ libopencv-dev

      # Step 5: Configure CMake
      - name: Configure (CMake)
        run: cmake -S private_tests -B build

      # Step 6: Build the Project
      - name: Build
        run: cmake --build build

      # Step 7: Run Tests with CTest (Allow Failure)
      - name: Run Tests (JUnit)
        run: ctest --test-dir build --output-on-failure --output-junit results.xml
        continue-on-error: true  # Allows the workflow to continue even if tests fail

      # Step 8: Parse JUnit Results, Calculate Score & Set Output
      - name: Parse JUnit, Calculate Score & Annotate
        id: grading  # Assign an ID to reference outputs later
        if: always()  # Ensure this step runs regardless of previous step outcomes
        run: |
          python3 <<EOF
          import xml.etree.ElementTree as ET
          import os
          
          # Define point values for each test
          test_points = {
            "Lab1Test.NegativeImage": 10,
            "Lab1Test.NegativeImage_EmptyMat": 5,
            "Lab1Test.NegativeImage_1x1": 5,
            "Lab1Test.AddScalar": 10,
            "Lab1Test.AddScalar_Zero": 3,
            "Lab1Test.AddScalar_Negative": 4,
            "Lab1Test.MulScalar_Regular": 10,
            "Lab1Test.MulScalar_ZeroFactor": 3,
            "Lab1Test.MulScalar_FactorGreaterThan1": 4,
            "Lab1Test.DrawSquares": 10,
            "Lab1Test.DrawSquares_2x2": 6
          }
          
          # Parse the JUnit XML results
          tree = ET.parse("build/results.xml")
          root = tree.getroot()
          total_score = 0
          
          output = []
          for testcase in root.iter("testcase"):
              name = testcase.get("name", "")
              failed = (testcase.find("failure") is not None or testcase.find("error") is not None)
              possible = test_points.get(name, 0)
              if not failed:
                  result = f"{name}: PASSED (+{possible} pts)"
                  total_score += possible
              else:
                  result = f"{name}: FAILED (+0 pts, was {possible} pts)"
              output.append(result)
          
          output.append("=========================================")
          output.append(f"TOTAL POINTS: {total_score}")
          
          # Print the output for logging
          print("\n".join(output))
          
          # Export the total score as a step output
          with open(os.environ['GITHUB_OUTPUT'], 'a') as env_file:
              env_file.write(f"points={total_score}\n")
          EOF

      # Step 9: Annotate the Repository with the Score (Using education/autograding Action)
      - name: Annotate with Score
        id: mark
        uses: markpatterson27/autograding@dev-points-input-release
        with:
          points: 10
          available-points: 100
